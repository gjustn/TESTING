import pygame
pygame.init()
import sys
import math
import random
import ctypes
import pygetwindow as gw

screen_width, screen_height = 800, 600
screen = pygame.display.set_mode((screen_width, screen_height), pygame.NOFRAME)
font = pygame.font.Font(None, 36)
def adjust_font_size(text, max_width, font_name='Arial'):
    font_size = 1
    adjusted_font = pygame.font.SysFont(font_name, font_size)
    while adjusted_font.size(text)[0] < max_width and font_size < 30:
        font_size += 1
        adjusted_font = pygame.font.SysFont(font_name, font_size)
    return pygame.font.SysFont(font_name, font_size - 1)
max_widths = [200, 50, 300]
white = (255, 255, 255)
blue = (0, 0, 255)
ctrl_p_pressed = False
ctrl_i_pressed = False
current_map = None
player1 = None

def draw_title_bar(screen):
    title_bar_height = 40
    title_bar_color = (50, 50, 50)
    pygame.draw.rect(screen, title_bar_color, (0, 0, screen_width, title_bar_height))
    font = pygame.font.Font(None, 24)
    title_text = font.render(f"{player1.name}'s Game", True, (255, 255, 255))
    title_text_width = title_text.get_width()
    screen.blit(title_text, (10, 10))
    
    minimize_button = pygame.Rect(screen_width - 60, 10, 20, 20)
    pygame.draw.rect(screen, (100, 100, 100), minimize_button)
    min_text = font.render("_", True, (255, 255, 255))
    screen.blit(min_text, (screen_width - 55, 5))

    close_button = pygame.Rect(screen_width - 30, 10, 20, 20)
    pygame.draw.rect(screen, (255, 0, 0), close_button)
    close_text = font.render("X", True, (255, 255, 255))
    screen.blit(close_text, (screen_width - 25, 12))

    return title_text_width, minimize_button, close_button, title_bar_height

dragging = False
drag_offset_x = 0
drag_offset_y = 0

class InputBox:
    def __init__(self, x, y, w, h, text=''):
        self.rect = pygame.Rect(x, y, w, h)
        self.color = pygame.Color('white')
        self.text = text
        self.txt_surface = font.render(text, True, self.color)
        self.active = False

    def handle_event(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN:
            if self.rect.collidepoint(event.pos):
                self.active = not self.active
            else:
                self.active = False
        if event.type == pygame.KEYDOWN:
            if self.active:
                if event.key == pygame.K_RETURN:
                    #print(self.text)
                    self.text = ''
                elif event.key == pygame.K_BACKSPACE:
                    self.text = self.text[:-1]
                else:
                    self.text += event.unicode
                self.txt_surface = font.render(self.text, True, self.color)

    def draw(self, screen):
        pygame.draw.rect(screen, self.color, self.rect, 2)
        screen.blit(self.txt_surface, (self.rect.x+5, self.rect.y+5))
input_box = InputBox(100, 100, 140, 32)
input_box.active = True

class Player:
    def __init__(self, name, current_health, max_health, level):
        self.name = name
        self.current_health = 100
        self.max_health = 100
        self.level = level
        self.bag = []
        self.x = 0
        self.y = 0
        self.width = 32
        self.height = 32
        self.rect = pygame.Rect(self.x, self.y, self.width, self.height)
        self.selected_item_index = 0
        self.poison_duration = 0
        self.hp_loss_per_step = 0
        self.prev_x = self.x
        self.prev_y = self.y
        self.distance_moved = 0

    def get_collision_rect(self):
        return pygame.Rect(self.rect.x + 8, self.rect.y, 16, self.rect.height)

    def playerActions(self):
        self.jump = ()
        self.pickUp = ()

    def attack(self, target):
        print(f"{self.name} attacks {target.name}!")

    def equipped(self):
        head = []
        chest = []
        arm_L = []
        arm_R = []
        legs = []
        feet = []
        hand_L = []
        hand_R = []
        
    def add_item(self, item):
        for existing_item in self.bag:
            if existing_item.name == item.name:
                existing_item.qty += 1
                break
        else:
            self.bag.append(item)

    def use_item(self, item_name):
        for item in self.bag:
            if item.name == item_name and item.is_consumable:
                item.qty -= 1
                if item.qty <= 0:
                    self.bag.remove(item)
                return item.item_effect(self)
        return None
    
    def apply_poison(self, duration, hp_loss_per_step):
        self.poison_duration = duration
        self.hp_loss_per_step = hp_loss_per_step
        print(f"Duration: {duration}, HP lost per step: {hp_loss_per_step}")
        print(f"You have been poisoned")
#       Add if statement for when current_health drops to 0 or below       
    def has_moved(self):
        return self.x != self.prev_x or self.y != self.prev_y
    def update_position(self, new_x, new_y):
        self.distance_moved += math.sqrt((new_x - self.prev_x) ** 2 + (new_y - self.prev_y) ** 2)
        self.prev_x = self.x
        self.prev_y = self.y
        self.x = new_x
        self.y = new_y
        if self.distance_moved >= 32:
            self.take_step()
            self.distance_moved -= 32
    def take_step(self):
        if self.poison_duration > 0:
            self.current_health -= self.hp_loss_per_step
            self.poison_duration -= 1
            print(f"Poison effect: Health = {self.current_health}, Duration left = {self.poison_duration}")            

class SpriteSheet:
    def __init__(self, filename):
        self.spritesheet = pygame.image.load(filename).convert_alpha()

    def get_image(self, x, y, width, height):
#       Extracts image from sprite sheet
        image = pygame.Surface((width, height), pygame.SRCALPHA)
        image.blit(self.spritesheet, (0, 0), (x, y, width, height))
        return image

class Item:
    def __init__(self, name, sprite, description, tileset_name, is_consumable=False, is_quest_item=False, is_equippable=False, effect=None, alignment='none', duration_range=(1, 5), hp_loss_range=(1, 3), qty=1, amount=0):
        self.id = id(self)
        self.name = name
        self.sprite = sprite.image
        self.tileset_name = tileset_name
        self.alignment = alignment
        self.is_consumable = is_consumable
        self.is_quest_item = is_quest_item
        self.is_equippable = is_equippable
        self.in_world = False
        self.in_inventory = False
        self.description = description
        self.effect = effect
        self.duration_range = duration_range
        self.hp_loss_range = hp_loss_range
        self.rect = None
        self.x = 0
        self.y = 0
        self.qty = qty
        self.amount = amount
        print(f"Created item: {self.name}, is_consumable: {self.is_consumable}, qty: {self.qty}, amount: {self.amount}")

    def place_in_world(self, x, y):
        self.in_world = True
        self.x = x
        self.y = y

    def pick_up(self, current_map):
        if self.in_world:
            self.in_world = False
            self.in_inventory = True
            for y, row in enumerate(current_map.data):
                for x, tile_data in enumerate(row):
                    if tile_data == self:
                        current_map.data[y][x] = 0

    def item_effect(self, player1):
        amount = self.amount
        if self.effect == 'heal':
            player1.current_health += amount
            if player1.current_health > player1.max_health:
                player1.current_health = player1.max_health
            print(f"Current Health: {player1.current_health}/{player1.max_health}")
        elif self.effect == 'poison':
            duration = random.randint(*self.duration_range)
            hp_loss_per_step = random.randint(*self.hp_loss_range)
            player1.apply_poison(duration, hp_loss_per_step)
            if player1.current_health <= 0:
                player1.current_health = 0
                print("Player has fainted/died")
        elif self.effect == 'increase_health':
            player1.max_health += amount
            print(f"Player Max health has incresed to {player1.max_health}")
        return player1.current_health, player1.max_health

def place_items(current_map, items):
    map_width = len(current_map.data[0])
    map_height = len(current_map.data)
    empty_space = [(x, y) for y, row in enumerate(current_map.data) for x, tile in enumerate(row) if tile == 0 or isinstance(tile, Item)]

    if not empty_space:
        raise ValueError("No empty space found")

    for item in items:
        chosen_space = random.choice(empty_space)
        empty_space.remove(chosen_space)
        tile_x, tile_y = chosen_space
        if 0 <= tile_x < map_width and 0 <= tile_y < map_height:
            x = tile_x * current_map.tile_size
            y = tile_y * current_map.tile_size
            item.x = x
            item.y = y
            item.rect = pygame.Rect(x, y, current_map.tile_size, current_map.tile_size)
            current_map.data[tile_y][tile_x] = item
            print(f"Added {item.name} to map ({x}, {y})")
            add_item_to_map(current_map, item, *chosen_space)
        
def add_item_to_map(current_map, item, x, y):
    current_map.data[y][x] = item
    item.x = x
    item.y = y
    print(f"Added {item.name} to map ({x}, {y})")

class Tile:
    def __init__(self, image, passable, size):
        self.image = image
        self.passable = passable
        self.size = size

class Tileset:
    def __init__(self, name, file, tile_specs):
        self.name = name
        self.file = file
        self.tile_specs = tile_specs
        self.image = pygame.image.load(file)
        self.tiles = self.load_tiles()

    def load_tiles(self):
        tiles = []
        for spec in self.tile_specs:
            game_size, grid_location, grid_size= spec
            grid_x, grid_y = grid_location
            grid_width, grid_height = grid_size
            tile_x, tile_y = grid_x * 16, grid_y * 16
            tile_width, tile_height = grid_width * 16, grid_height * 16
            rect = pygame.Rect(tile_x, tile_y, tile_width, tile_height)
            image = self.image.subsurface(rect)
            aspect_ratio = tile_width / tile_height
            new_width = game_size[0]
            new_height = round(new_width / aspect_ratio)
            scaled_image = pygame.transform.scale(image, (new_width, new_height)) 
            passable = self.check_passable(scaled_image)
            tile = Tile(scaled_image, passable, (new_width, new_height))
            tiles.append(tile)
        return tiles
    
    def check_passable(self, scaled_image):
        return True

class ObjectTiles:
    fruit_specs = [
        ((16, 17), (0, 0), (1, 1)),  # 0
        ((16, 17), (1, 0), (1, 1)),  # 1
        ((16, 17), (2, 0), (1, 1))   # 2
    ]
    potion_specs = [
        ((16, 17), (0, 0), (1, 1)),
        ((16, 17), (1, 0), (1, 1)),
        ((16, 17), (2, 0), (1, 1))
    ]

    apple_tile = Tileset('apple', 'assets/ItemsSprites/apple.png', fruit_specs)
    poisoned_apple_tile = Tileset('poisoned_apple', 'assets/ItemsSprites/poisoned_apple.png', fruit_specs)
    bannana_tile = Tileset('bannana', 'assets/ItemsSprites/bannana.png', fruit_specs)
    health_potion_tile = Tileset('potion', 'assets/ItemsSprites/potion1.png', potion_specs)

class Animation:
    def __init__(self, frames, frame_delay, start_frame=0):
        self.frames = frames
        self.frame_delay = frame_delay
        self.current_frame = start_frame
        self.counter = 0
        self.pattern = self.generate_pattern(start_frame)

    def generate_pattern(self, start_frame):
        num_frames = len(self.frames)
        pattern = list(range(start_frame, num_frames)) + list(range(num_frames - 2, start_frame - 1, -1))
        return pattern

    def update(self):
        self.counter += 1
        if self.counter >= self.frame_delay:
            self.counter = 0
            self. current_frame = (self.current_frame + 1) % len(self.pattern)

    def get_current_frame(self):
        return self.frames[self.pattern[self.current_frame]]

class GameMap:
    def __init__(self, data, tile_size, tilesets):
        self.data = data
        self.tile_size = tile_size
        self.tilesets = tilesets
        self.shared_animations = {}

        animation_configs = [
            ('apple', 'apple', 30, 3),
            ('poisoned_apple', 'poisoned_apple', 10, 3),
            ('bannana', 'bannana', 10, 3),
            ('potion', 'potion', 10, 3)
        ]

        for anim_name, tileset_name, frame_delay, frame_count in animation_configs:
            if anim_name not in self.shared_animations:
                # Check if the tileset has enough frames
                if len(self.tilesets[tileset_name].tiles) >= frame_count:
                    frames = [self.tilesets[tileset_name].tiles[i].image for i in range(frame_count)]
                    self.shared_animations[anim_name] = Animation(frames, frame_delay=frame_delay, start_frame=0)
                else:
                    print(f"Warning: '{tileset_name}' tileset has fewer than {frame_count} frames.")

    def draw_grid(self):  # \!/\!/\!/ COMMENT OUT IN PRODUCTION \!/\!/\!/
        tile_size = 32
        border_width = 1
        border_color = (255, 0, 0)
        num_tiles_x = screen_width // tile_size
        num_tiles_y = screen_height // tile_size
        for i in range(num_tiles_x):
            for j in range(num_tiles_y):
                tile_rect = pygame.Rect(i*tile_size, j*tile_size, tile_size, tile_size)
                pygame.draw.rect(screen, border_color, tile_rect, border_width)

    def draw_background(self, screen, tile_size=32):
        background_data = [
            [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0],
            [2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2],
            [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0],
            [2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2],
            [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0],
            [2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2],
            [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0],
            [2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2],
            [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0],
            [2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2],
            [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0],
            [2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2],
            [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0],
            [2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2],
            [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0],
            [2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2],
            [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0],
            [2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2],
            [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0]
        ]
        for y, row in enumerate(background_data):
            for x, tile_index in enumerate(row):
                tileset = self.tilesets['Background1']
                tile = tileset.tiles[tile_index]
                draw_x = x * tile_size
                draw_y = y * tile_size
                screen.blit(tile.image, (draw_x, draw_y))

    def draw_map(self, screen, tile_size=32):
        blocks = []
        pass_under_blocks = []

        def adjust_alignment(rect, alignment, tile_size):
            if alignment == 'top':
                rect.x += (tile_size - rect.width) // 2
            elif alignment == 'left':
                rect.y += (tile_size - rect.height) // 2
            elif alignment == 'right':
                rect.x += tile_size - rect.width
                rect.y += (tile_size - rect.height) // 2
            elif alignment == 'bottom':
                rect.y += tile_size - rect.height
                rect.x += (tile_size - rect.width) // 2
            elif alignment == 'center':
                rect.x += (tile_size - rect.width) // 2
                rect.y += (tile_size - rect.height) // 2
            return rect

        for y, row in enumerate(self.data):
            for x, tile_data in enumerate(row):
                if isinstance(tile_data, Item):
                    item = tile_data
                    animation = self.shared_animations[item.tileset_name]
                    animation.update()
                    current_frame = animation.get_current_frame()
                    item.rect = pygame.Rect(item.x * tile_size, item.y * tile_size, current_frame.get_width(), current_frame.get_height())
                    blocks.append((item.rect, item))
                    item.rect = adjust_alignment(item.rect, item.alignment, tile_size)
                    screen.blit(current_frame, (item.rect.x, item.rect.y))
                elif isinstance(tile_data, (list, tuple)):
                    tileset_name, tile_index = tile_data[0], tile_data[1]
                    tileset = self.tilesets[tileset_name]
                    tile = tileset.tiles[tile_index]
                    block_rect = pygame.Rect(x * tile_size, y * tile_size, tile.image.get_width(), tile.image.get_height())
                    if 'alignment' in tile_data:
                        alignment = tile_data[2]
                        block_rect = adjust_alignment(block_rect, alignment, tile_size)
                    screen.blit(tile.image, (block_rect.x, block_rect.y))
                    tile_type = tile_data[-1]
                    block = pygame.Rect(block_rect.x, block_rect.y, tile.image.get_width(), tile.image.get_height())
                    if tile_type == 1:
                        if tile_index in range(18, 21):
                            game_size, grid_location, grid_size = tileset1_specs[tile_index]
                            grid_x, grid_y = grid_location
                            grid_width, grid_height = grid_size
                            block_section = pygame.Rect(block_rect.x + int(3 * grid_width), block_rect.y + int(3 * grid_height), int(2 * grid_width), int(2 * grid_height))
                            blocks.append((block_section, tile_type))
                        elif tile_index in range(45, 51):
                            game_size, grid_location, grid_size = tileset1_specs[tile_index]
                            grid_x, grid_y = grid_location
                            grid_width, grid_height = grid_size
                            block_section = pygame.Rect(block_rect.x + int(2.5 * grid_width), block_rect.y + int(2.5 * grid_height), int(0.4 * grid_width), int(0.4 * grid_height))
                            blocks.append((block_section, tile_type))
                        else:
                            blocks.append((block, tile_type))
                    elif tile_type in [2, 6]:
                        block.height //= 2
                        blocks.append((block, tile_type))
                    elif tile_type in [3, 7]:
                        block.height //= 2
                        block.y += block.height
                        pass_under_blocks.append((block, tile_type))
                    elif tile_type == 4:
                        block_top = block.copy()
                        block_top.height //= 2
                        block_bottom = block.copy()
                        block_bottom.height //= 2
                        block_bottom.y += block_bottom.height
                        blocks.append((block_top, tile_type))
                        pass_under_blocks.append((block_bottom, tile_type))
                    elif tile_type == 5:
                        block_top = block.copy()
                        block_top.height //= 2
                        block_bottom = block.copy()
                        block_bottom.height //= 2
                        block_bottom.y += block_bottom.height
                        pass_under_blocks.append((block_top, tile_type))
                        blocks.append((block_bottom, tile_type))
                    elif tile_type == 8:
                        block_left = block.copy()
                        block_left.width //= 2
                        block_right = block.copy()
                        block_right.width //= 2
                        block_right.x += block_right.width
                        blocks.append((block_left, tile_type))
                        pass_under_blocks.append((block_right, tile_type))
                    elif tile_type == 9:
                        block_left = block.copy()
                        block_left.width //= 2
                        block_right = block.copy()
                        block_right.width //= 2
                        block_right.x += block_right.width
                        pass_under_blocks.append((block_left, tile_type))
                        blocks.append((block_right, tile_type))
        return blocks, pass_under_blocks 

tileset1_specs = [
    # Tree01 - SEGMENTED
    ((32, 32), (1, 0), (4, 4)),  # 0
    ((32, 32), (5, 0), (4, 4)),  # 1
    ((32, 32), (1, 4), (4, 4)),  # 2
    ((32, 32), (5, 4), (4, 4)),  # 3
    ((32, 32), (1, 8), (4, 4)),  # 4
    ((32, 32), (5, 8), (4, 4)),  # 5
    # Tree02 - SEGMENTED
    ((24, 24), (10, 1), (3, 3)), # 6
    ((24, 24), (13, 1), (3, 3)), # 7
    ((24, 32), (10, 4), (3, 4)), # 8
    ((24, 32), (13, 4), (3, 4)), # 9
    ((8, 16), (12, 8), (1, 2)),  # 10
    ((8, 16), (13, 8), (1, 2)),  # 11
    # Tree03 - SEGMENTED
    ((24, 24), (18, 2), (3, 3)), # 12
    ((24, 24), (22, 2), (3, 3)), # 13
    ((24, 24), (18, 5), (3, 3)), # 14
    ((24, 24), (22, 5), (3, 3)), # 15
    ((8, 16), (20, 8), (1, 2)),  # 16
    ((8, 16), (21, 8), (1, 2)),  # 17
    # Tree01 - WHOLE
    ((64, 96), (1, 0), (8, 10)), # 18
    # Tree02 - WHOLE
    ((48, 72), (10, 1), (6, 9)), # 19
    # Tree03 - WHOLE
    ((48, 64), (18, 2), (6, 8)), # 20
    # Bush01 - SEGMENTED
    ((8, 8), (2, 12), (1, 1)),   # 21
    ((8, 8), (3, 12), (1, 1)),   # 22
    ((8, 8), (2, 13), (1, 1)),   # 23
    ((8, 8), (3, 13), (1, 1)),   # 24
    # Bush02 - SEGMENTED
    ((8, 8), (6, 12), (1, 1)),   # 25
    ((8, 8), (7, 12), (1, 1)),   # 26
    ((8, 8), (6, 13), (1, 1)),   # 27
    ((8, 8), (7, 13), (1, 1)),   # 28
    # Bush03 - SEGMENTED
    ((16, 16), (9, 11), (2, 2)), # 29
    ((16, 16), (11, 11), (2, 2)),# 30
    ((16, 8), (9, 13), (2, 1)),  # 31
    ((16, 8), (11, 13), (2, 1)), # 32
    # Bush04 - SEGMENTED
    ((16, 16), (13, 11), (2, 2)),# 33
    ((16, 16), (15, 11), (2, 2)),# 34
    ((16, 16), (13, 13), (2, 2)),# 35
    ((16, 16), (15, 13), (2, 2)),# 36
    # Bush05 - SEGMENTED
    ((16, 16), (17, 11), (2, 2)),# 37
    ((16, 16), (19, 11), (2, 2)),# 38
    ((16, 16), (17, 13), (2, 2)),# 39
    ((16, 16), (19, 13), (2, 2)),# 40
    # Bush06 - SEGMENTED
    ((16, 16), (21, 11), (2, 2)),# 41
    ((16, 16), (23, 11), (2, 2)),# 42
    ((16, 16), (21, 13), (2, 2)),# 43
    ((16, 16), (23, 13), (2, 2)),# 44
    # Bush01 - WHOLE
    ((16, 16), (2, 12), (2, 2)), # 45
    # Bush02 - WHOLE
    ((16, 16), (6, 12), (2, 2)), # 46
    # Bush03 - WHOLE
    ((16, 24), (9, 12), (4, 3)), # 47
    # Bush04 - WHOLE
    ((32, 32), (13, 11), (4, 4)), # 48
    # Bush05 - WHOLE
    ((32, 32), (17, 11), (4, 4)), # 49
    # Bush06 - WHOLE
    ((32, 32), (21, 11), (4, 4)) # 50
    # Remember to add grass from this tileset
]
tileset2_specs = []
background1_specs = [
    ((32, 32), (0, 0), (4, 4)),  # 0
    ((32, 32), (4, 0), (4, 4)),  # 1
    ((32, 32), (0, 4), (4, 4)),  # 2
    ((32, 32), (4, 4), (4, 4))   # 3
]

background = Tileset('Background1', 'assets/tilesets/Texture/TX Tileset Grass.png', background1_specs)
tileset1 = Tileset('Plantset 1', 'assets/tilesets/Texture/TX Plant.png', tileset1_specs)
#tileset2 = Tileset('Propset 2', 'C:/Users/justn/OneDrive/Desktop/myGame/assets/tilesets/Texture/TX Props.png', tileset2_specs)
#tileset3 = tilesets.Tileset('Tileset 3', 'path_to.png', [(px, px)])
#tileset4 = tilesets.Tileset('Tileset 4', 'path_to.png', [(px, px)])
#tileset5 = tilesets.Tileset('Tileset 5', 'path_to.png', [(px, px)])

tileset_dict = {'Background1': background, 'Plantset 1': tileset1, 'apple': ObjectTiles.apple_tile, 'bannana': ObjectTiles.bannana_tile, 'poisoned_apple': ObjectTiles.poisoned_apple_tile, 'potion': ObjectTiles.health_potion_tile}

apple = tileset_dict['apple'].tiles[0]
bannana = tileset_dict['bannana'].tiles[0]
poisoned_apple = tileset_dict['poisoned_apple'].tiles[0]
potion = tileset_dict['potion'].tiles[0]
#apple_quest = Item('apple_quest', apple, 'This is a delicious looking apple.', is_consumable=False, is_quest_item=True, is_equippable=False, alignment='bottom')
#apple_eat = Item('apple_eat', apple, 'This is a delicious looking apple.', is_consumable=True, is_quest_item=False, is_equippable=False, alignment='bottom')
apples = [Item('Apple', apple, 'This is a delicious looking apple.', 'apple', is_consumable=True, effect='heal', alignment='bottom', amount=5) for _ in range(3)]
poisoned_apple = Item('Poisoned Apple', poisoned_apple, 'This apple looks odd but still irresitable.', 'poisoned_apple', is_consumable=True, effect='poison', duration_range=(7, 15), hp_loss_range=(1, 3), alignment='bottom')
bannana_test = Item('Rubber Bannana', bannana, 'This is a bannana.', 'bannana', alignment='bottom')
health_potion = Item('Health Potion', potion, 'This should help you stay alive a bit longer', 'potion', is_consumable=True, effect='increase_health', alignment='bottom', amount=10)

map_test_data = [
    [('Plantset 1', 18, 'right', 1), ('Plantset 1', 20, 'right', 1), ('Plantset 1', 19, 'right', 1), ('Plantset 1', 18, 'right', 1), ('Plantset 1', 20, 'right', 1), ('Plantset 1', 19, 'right', 1), ('Plantset 1', 18, 'right', 1), ('Plantset 1', 20, 'right', 1), ('Plantset 1', 19, 'right', 1), ('Plantset 1', 18, 'right', 1), ('Plantset 1', 20, 'right', 1), ('Plantset 1', 19, 'right', 1), ('Plantset 1', 18, 'right', 1), ('Plantset 1', 20, 'right', 1), ('Plantset 1', 19, 'right', 1), ('Plantset 1', 18, 'right', 1), ('Plantset 1', 20, 'right', 1), ('Plantset 1', 19, 'right', 1), ('Plantset 1', 18, 'right', 1), ('Plantset 1', 20, 'right', 1), ('Plantset 1', 19, 'right', 1), ('Plantset 1', 18, 'right', 1), ('Plantset 1', 20, 'right', 1), ('Plantset 1', 19, 'right', 1), ('Plantset 1', 18, 'right', 1), ('Plantset 1', 20, 'right', 1)],
    [('Plantset 1', 20, 'center', 1), ('Plantset 1', 19, 'center', 1), ('Plantset 1', 18, 'center', 1), ('Plantset 1', 20, 'center', 1), ('Plantset 1', 19, 'center', 1), ('Plantset 1', 18, 'center', 1), ('Plantset 1', 20, 'center', 1), ('Plantset 1', 19, 'center', 1), ('Plantset 1', 18, 'center', 1), ('Plantset 1', 20, 'center', 1), ('Plantset 1', 19, 'center', 1), ('Plantset 1', 18, 'center', 1), ('Plantset 1', 20, 'center', 1), ('Plantset 1', 19, 'center', 1), ('Plantset 1', 18, 'center', 1), ('Plantset 1', 20, 'center', 1), ('Plantset 1', 19, 'center', 1), ('Plantset 1', 18, 'center', 1), ('Plantset 1', 20, 'center', 1), ('Plantset 1', 19, 'center', 1), ('Plantset 1', 18, 'center', 1), ('Plantset 1', 20, 'center', 1), ('Plantset 1', 19, 'center', 1), ('Plantset 1', 18, 'center', 1), ('Plantset 1', 20, 'center', 1), ('Plantset 1', 19, 'center', 1)],
    [('Plantset 1', 18, 'right', 1), ('Plantset 1', 20, 'right', 1), ('Plantset 1', 19, 'right', 1), ('Plantset 1', 18, 'right', 1), ('Plantset 1', 20, 'right', 1), ('Plantset 1', 19, 'right', 1), ('Plantset 1', 18, 'right', 1), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ('Plantset 1', 18, 'right', 1), ('Plantset 1', 20, 'right', 1), ('Plantset 1', 19, 'right', 1), ('Plantset 1', 18, 'right', 1), ('Plantset 1', 20, 'right', 1), ('Plantset 1', 19, 'right', 1), ('Plantset 1', 18, 'right', 1)],
    [('Plantset 1', 20, 'center', 1), ('Plantset 1', 19, 'center', 1), ('Plantset 1', 18, 'center', 1), ('Plantset 1', 20, 'center', 1), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ('Plantset 1', 19, 'center', 1), ('Plantset 1', 18, 'center', 1), ('Plantset 1', 20, 'center', 1), ('Plantset 1', 19, 'center', 1)],
    [('Plantset 1', 18, 'right', 1), ('Plantset 1', 20, 'right', 1), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ('Plantset 1', 20, 'right', 1), ('Plantset 1', 19, 'right', 1)],
    [('Plantset 1', 20, 'center', 1), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ('Plantset 1', 20, 'center', 1)],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
]
map_01_data = []
map_02_data = []
map_03_data = []
map_test = GameMap(map_test_data, 32, tileset_dict)
map_01 = GameMap(map_01_data, 32,  tileset_dict)
map_02 = GameMap(map_01_data, 32,  tileset_dict)
map_03 = GameMap(map_01_data, 32,  tileset_dict)

# Character customization assets
skin_tones = ['assets/CharacterSprites/Skins/BrownMale.png',
              'assets/CharacterSprites/Skins/DBrownMale.png',
              'assets/CharacterSprites/Skins/DeepMale.png',
              'assets/CharacterSprites/Skins/EbonyMale.png',
              'assets/CharacterSprites/Skins/FairMale.png',
              'assets/CharacterSprites/Skins/LightMale.png',
              'assets/CharacterSprites/Skins/MediumMale.png',
              'assets/CharacterSprites/Skins/OliveMale.png',
              'assets/CharacterSprites/Skins/PaleMale.png',
              'assets/CharacterSprites/Skins/TanMale.png'
]
eye_colors = ['assets/CharacterSprites/Eyes/BlackEye.png',
              'assets/CharacterSprites/Eyes/BlueEye.png',
              'assets/CharacterSprites/Eyes/GreenEye.png',
              'assets/CharacterSprites/Eyes/PurpleEye.png',
              'assets/CharacterSprites/Eyes/WhiteEye.png',
]

def draw_health_bar(screen, current_health, max_health, title_text_width):
    bar_width = 200
    bar_height = 20
    bar_x = 10 + title_text_width + 10
    bar_y = 10

    border_color = (0, 0, 0)
    bar_color = (255, 0, 0)
    border_thickness = 4

    health_percentage = current_health / max_health
    fill_width = bar_width * health_percentage

    pygame.draw.rect(screen, bar_color, (bar_x, bar_y, fill_width, bar_height), border_radius=10)
    pygame.draw.rect(screen, border_color, (bar_x, bar_y, bar_width, bar_height), border_thickness, border_radius=10)

def check_collision(player_rect, block_rect, player_tile, tile, current_map, player1):
#   Define the four quadrants of the block
    block01 = pygame.Rect(block_rect.x, block_rect.y, block_rect.width // 2, block_rect.height // 2)
    block02 = pygame.Rect(block_rect.x + block_rect.width // 2, block_rect.y, block_rect.width // 2, block_rect.height // 2)
    block03 = pygame.Rect(block_rect.x + block_rect.width // 2, block_rect.y + block_rect.height // 2, block_rect.width // 2, block_rect.height // 2)
    block04 = pygame.Rect(block_rect.x, block_rect.y + block_rect.height // 2, block_rect.width // 2, block_rect.height // 2)
    
    if player_rect.colliderect(block_rect):
        if isinstance(tile, Item):
            print(f"Collision detected with {tile.name}!")  # Print the name of the item
            print(f"Tile Position: ({block_rect.x, block_rect.y})\nPlayer Position: {player_tile.x, player_tile.y}")
            tile.pick_up(current_map)
            player1.add_item(tile)
            print(f"{tile.name} has been added to the players bag.")
            tile.in_world = False
            current_map.data[block_rect.y // current_map.tile_size][block_rect.x // current_map.tile_size] = 0
            for y, row in enumerate(current_map.data):
                for x, tile_data in enumerate(row):
                    if isinstance(tile_data, Item) and tile_data.id == tile.id:
                        current_map.data[y][x] = 0
            return True
        elif isinstance(tile, int):
            print(f"Collision detected with {tile}!")
            print(f"Tile Position: {block_rect.x, block_rect.y}\nPlayer Position: {player_tile.x, player_tile.y}")
#   Define the collision behavior for each tile type
            if tile == 1:
                return player_rect.colliderect(block_rect)
            elif tile == 2:
                return player_rect.colliderect(block01) or player_rect.colliderect(block02)
            elif tile == 3:
                return player_rect.colliderect(block03) or player_rect.colliderect(block04)
            elif tile == 4:
                return player_rect.colliderect(block01) or player_rect.colliderect(block02)
            elif tile == 5:
                return player_rect.colliderect(block03) or player_rect.colliderect(block04)
            elif tile == 6:
                return player_rect.colliderect(block01) or player_rect.colliderect(block04)
            elif tile == 7:
                return player_rect.colliderect(block02) or player_rect.colliderect(block03)
            elif tile == 8:
                return player_rect.colliderect(block01) or player_rect.colliderect(block04)
            elif tile == 9:
                return player_rect.colliderect(block02) or player_rect.colliderect(block03)
            else:
                return player_rect.colliderect(block_rect)
    return False

def draw_menu():
    draw_background()
    hello_text = font.render("Hello", True, white)
    screen.blit(hello_text, (screen_width // 2 - hello_text.get_width() // 2, screen_height //2 - hello_text.get_height() // 2))
    start_text = font.render("Start Game", True, white)
    text_width, text_height = start_text.get_size()
    start_button = pygame.Rect(screen_width // 2 - text_width // 2, screen_height // 2 + 50, text_width, text_height)
    pygame.draw.rect(screen, blue, start_button)
    screen.blit(start_text, (screen_width // 2 - start_text.get_width() // 2, screen_height // 2 + 50))
    return start_button

def draw_background():
    menu_width, menu_height = screen_width // 2, screen_height // 2
    menu_x, menu_y = screen_width // 4, screen_height // 4
    menu_rect = pygame.Rect(menu_x, menu_y , menu_width, menu_height)
    pygame.draw.rect(screen, blue, menu_rect, border_radius=10)
    border_width = 5
    pygame.draw.rect(screen, white, menu_rect, border_width, border_radius=10)
    return menu_rect

def main():
    global ctrl_p_pressed, ctrl_i_pressed, current_map, player1
    frame_counter = 0
    frame_delay = 10
    menu = True
    name_input = False
    character_creator = False
    welcome = False
    game = False
    items_placed = False
    menu_y = screen_height // 2
    menu_height = screen_height // 2
    menu_width, menu_height = screen_width // 2, screen_height // 2
    menu_x, menu_y = screen_width // 4, screen_height // 4
    menu_rect = pygame.Rect(menu_x, menu_y , menu_width, menu_height)
    start_ticks = pygame.time.get_ticks()
    grid_center_x = menu_rect.x + menu_rect.width // 2
    grid_center_y = menu_rect.y + menu_rect.height // 2
    game_area = pygame.Rect(0, 0, screen_width, screen_height)
    tiles_to_center_x = grid_center_x // 32
    tiles_to_center_y = grid_center_y // 32
    player_x = tiles_to_center_x * 32
    player_y = tiles_to_center_y * 32
    player_tile = pygame.Rect(player_x, player_y, 32, 32)

    frame_width, frame_height = 25, 57
    move_spritesheet = SpriteSheet('assets/CharacterSprites/Movements/64x48 8d chara M1-01.png') # Male Sprite
    w_down =  [(10, 7), (59, 7), (108, 7)]
    w_left = [(10, 71), (59, 71), (108, 71)]
    w_right = [(10, 135), (59, 135), (108, 135)]
    w_up = [(10, 199), (59, 199), (108, 199)]
    w_L_down = [(154, 7), (203, 7), (252, 7)]
    w_R_down = [(154, 71), (203, 71), (252, 71)]
    w_L_up = [(154, 135), (203, 135), (252, 135)]
    w_R_up = [(154, 199), (203, 199), (252, 199)]
    idle_down = [(59, 7)]
    idle_left = [(59, 71)]
    idle_right = [(59, 135)]
    idle_up = [(59, 199)]
    idle_L_down = [(203, 7)]
    idle_R_down = [(203, 71)]
    idle_L_up = [(203, 135)]
    idle_R_up = [(203, 199)]

    current_action = 'idle'
    direction = 'down'
    current_sprite = 0
    frames = []
    frame_indices = {
        'idle': {'down': idle_down, 'left': idle_left, 'right': idle_right, 'up': idle_up, 'L_down': idle_L_down, 'R_down': idle_R_down, 'L_up': idle_L_up, 'R_up': idle_R_up},
        'walk': {'down': w_down, 'left': w_left, 'right': w_right, 'up': w_up, 'L_down': w_L_down, 'R_down': w_R_down, 'L_up': w_L_up, 'R_up': w_R_up}
    }

    if current_action == 'walk':
        if direction == 'down':
            frames = w_down
        elif direction == 'left':
            frames = w_left
        elif direction == 'right':
            frames = w_right
        elif direction == 'up':
            frames = w_up
        elif direction == 'L_down':
            frames = w_L_down
        elif direction == 'R_down':
            frames = w_R_down
        elif direction == 'L_up':
            frames = w_L_up
        elif direction == 'R_up':
            frames = w_R_up
    elif current_action == 'idle':
        if direction == 'down':
            frames = idle_down
        elif direction == 'left':
            frames = idle_left
        elif direction == 'right':
            frames = idle_right
        elif direction == 'up':
            frames = idle_up
        elif direction == 'L_down':
            frames = idle_L_down
        elif direction == 'R_down':
            frames = idle_R_down
        elif direction == 'L_up':
            frames = idle_L_up
        elif direction == 'R_up':
            frames = idle_R_up
        current_sprite = min(current_sprite, len(frames) - 1)

    x, y = 0, 0
    if frames:
        #print(f"Accessing frames[{current_sprite}]")
        x, y = frames[current_sprite]
        if current_action != 'idle': 
            current_sprite = (current_sprite + 1) % len(frames)

    grid_cell_width = 16
    grid_cell_height = 16
    grid_sprite_width = 1.6875
    grid_sprite_height = 4
    pixel_sprite_width = int(grid_sprite_width * grid_cell_width)
    pixel_sprite_height = int(grid_sprite_height * grid_cell_height)
    player_sprite = move_spritesheet.get_image(x, y, pixel_sprite_width, pixel_sprite_height)

    screen.blit(player_sprite, (player_tile.x, player_tile.y))    
    name = ""
    time = 0
    player1 = Player(name, 100, 100 , 1)
    start_ticks = pygame.time.get_ticks()
    show_background = True
    blocks = []
    pass_under_blocks = []
    clock = pygame.time.Clock()
    speed = 2

    while menu:
        draw_background()
        start_button = draw_menu()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                mouse_pos = pygame.mouse.get_pos()
                if start_button.collidepoint(mouse_pos):
                    menu = False
                    name_input = True
        pygame.display.update()

    while name_input:
        draw_background()
        global font
        prompt_text = font.render("What is your name?", True, white)
        screen.blit(prompt_text, (screen_width // 2 - prompt_text.get_width() // 2, screen_height // 2 - prompt_text.get_height() // 2))
        input_box.rect.x = screen_width // 2 - input_box.rect.w // 2
        input_box.rect.y = screen_height //2 + prompt_text.get_height()
        input_box.draw(screen)
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
                if input_box.text != '':
                    name_input = False
                    name = input_box.text
                    player1 = Player(name, 100, 100, 1)
                    character_creator = True
            input_box.handle_event(event)
        pygame.display.update()

    skin_index = 0
    eye_index = 0

    while character_creator:
        draw_background()
        skin_spritesheet = SpriteSheet(skin_tones[skin_index])
        eye_spritesheet = SpriteSheet(eye_colors[eye_index])

        # Get the specific segment of the sprite
        segment_rect = pygame.Rect(1.8, 1, 23, 24)
        player_sprite = skin_spritesheet.get_image(x, y, pixel_sprite_width, pixel_sprite_height).subsurface(segment_rect)
        eye_sprite = eye_spritesheet.get_image(x, y, pixel_sprite_width, pixel_sprite_height).subsurface(segment_rect)

        # Combine the skin and eye sprites
        player_sprite.blit(eye_sprite, (0, 0))

        # Scale the segment for better visibility
        player_sprite = pygame.transform.scale(player_sprite, (23 * 4, 24 * 4))
        screen.blit(player_sprite, (screen_width // 2 - player_sprite.get_width() // 2, screen_height // 2 - player_sprite.get_height() // 2))

        prompt_font = pygame.font.Font(pygame.font.match_font('Arial'), 24)
        prompt_text = prompt_font.render("Customize your character", True, white)
        prompt_shadow = prompt_font.render("Customize your character", True, (50, 50, 50))
        screen.blit(prompt_shadow, (screen_width // 2 - prompt_shadow.get_width() // 2 + 2, screen_height // 2 - prompt_text.get_height() - 102))
        screen.blit(prompt_text, (screen_width // 2 - prompt_text.get_width() // 2, screen_height // 2 - prompt_text.get_height() - 100))

        instructions_font = pygame.font.Font(pygame.font.match_font('Arial'), 18)
        instructions_text1 = instructions_font.render("Use the arrow keys to change skin tone and eye color.", True, white)
        instructions_text2 = instructions_font.render("Press Enter to confirm.", True, white)
        instructions_shadow1 = instructions_font.render("Use the arrow keys to change skin tone and eye color.", True, (50, 50, 50))
        instructions_shadow2 = instructions_font.render("Press Enter to confirm.", True, (50, 50, 50))

        screen.blit(instructions_shadow1, (screen_width // 2 - instructions_shadow1.get_width() // 2 + 2, screen_height // 2 + player_sprite.get_height() + 5))
        screen.blit(instructions_text1, (screen_width // 2 - instructions_text1.get_width() // 2, screen_height // 2 + player_sprite.get_height() + 3))
        screen.blit(instructions_shadow2, (screen_width // 2 - instructions_shadow2.get_width() // 2 + 2, screen_height // 2 + player_sprite.get_height() + 5 + instructions_text1.get_height()))
        screen.blit(instructions_text2, (screen_width // 2 - instructions_text2.get_width() // 2, screen_height // 2 + player_sprite.get_height() + 3 + instructions_text1.get_height()))

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_LEFT:
                    skin_index = (skin_index - 1) % len(skin_tones)
                elif event.key == pygame.K_RIGHT:
                    skin_index = (skin_index + 1) % len(skin_tones)
                elif event.key == pygame.K_UP:
                    eye_index = (eye_index - 1) % len(eye_colors)
                elif event.key == pygame.K_DOWN:
                    eye_index = (eye_index + 1) % len(eye_colors)
                elif event.key == pygame.K_RETURN:
                    selected_skin_tone = skin_tones[skin_index]
                    selected_eye_color = eye_colors[eye_index]
                    character_creator = False
                    welcome = True
        pygame.display.update()


    while welcome:
        show_background = True
        if show_background:
            draw_background()
            welcome_text = font.render(f"Welcome {name}!", True, white)
            screen.blit(welcome_text, (screen_width // 2 - welcome_text.get_width() // 2, screen_height // 2 - welcome_text.get_height() // 2))
        seconds=(pygame.time.get_ticks()-start_ticks)/1000 

        if seconds > 2:
            show_background = False
            prompt_font = pygame.font.Font(None, 24)
            prompt_text = prompt_font.render("Press [SPACE] to continue", True, white)
            alpha_surface = pygame.Surface(prompt_text.get_size(), pygame.SRCALPHA)
            alpha = (math.sin(time) + 1) / 2
            alpha_surface.fill((255, 255, 255, alpha * 255))
            alpha_surface.blit(prompt_text, (0, 0), special_flags=pygame.BLEND_RGBA_MULT)
            screen.blit(alpha_surface, (screen_width // 2 - prompt_text.get_width() // 2, menu_y + menu_height - prompt_text.get_height() - 10))
        time += 0.008

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
                welcome = False
                game = True
        pygame.display.update()

    while game:
        screen.fill((0, 0, 0))
        current_map = map_test
        current_map.draw_background(screen)
        blocks, pass_under_blocks = current_map.draw_map(screen)
        item_rects = []

##### Add items to the map
        if not items_placed:
            place_items(current_map, apples + [poisoned_apple, bannana_test, health_potion])
            items_placed = True
        #print(f"current_map: {current_map.data}\nEND")
##########################

        # Get the state of all keys
        keys = pygame.key.get_pressed()
        new_x = player_tile.x
        new_y = player_tile.y
        previous_action = current_action
        previous_direction = direction

        if keys[pygame.K_UP] or keys[pygame.K_w]:
            new_y -= speed
            if keys[pygame.K_LEFT] or keys[pygame.K_a]:
                new_x -= speed
                direction = 'L_up'
            elif keys[pygame.K_RIGHT] or keys[pygame.K_d]:
                new_x += speed
                direction = 'R_up'
            else:
                direction = 'up'
        elif keys[pygame.K_DOWN] or keys[pygame.K_s]:
            new_y += speed
            if keys[pygame.K_LEFT] or keys[pygame.K_a]:
                new_x -= speed
                direction = 'L_down'
            elif keys[pygame.K_RIGHT] or keys[pygame.K_d]:
                new_x += speed
                direction = 'R_down'
            else:
                direction = 'down'
        elif keys[pygame.K_LEFT] or keys[pygame.K_a]:
            direction = 'left'
            new_x -= speed
        elif keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            direction = 'right'
            new_x += speed
        if not any(keys):
            current_action = 'idle'
        else:
            current_action = 'walk'        

        collision_rect = player1.get_collision_rect()
        collision_check = any(check_collision(collision_rect, new_rect, block_rect, player_tile, tile, current_map, player1) for block_rect, tile, tile_type in blocks and pass_under_blocks)
        if not collision_check:
        # Update player's position
            prev_x = player_tile.x
            prev_y = player_tile.y
            player_tile.x = new_x
            player_tile.y = new_y
            player1.update_position(new_x, new_y)

        if current_action == 'idle':
            current_sprite = 0
            if direction == 'down':
                frames = idle_down
        if direction != previous_direction:
            current_sprite = 0
        if not any([keys[pygame.K_UP], keys[pygame.K_DOWN], keys[pygame.K_LEFT], keys[pygame.K_RIGHT]]):
            current_action = 'idle'
            if direction == 'down':
                frames = idle_down
            elif direction == 'up':
                frames = idle_up
            elif direction == 'left':
                frames = idle_left
            elif direction == 'right':
                frames = idle_right
            
        frame_counter += 1
        if frame_counter >= frame_delay:
            frame_counter = 0
            if current_action != previous_action or direction != previous_direction:
                current_sprite = 0
            else:
                if current_action != 'idle':
                    current_sprite = (current_sprite + 1) % len(frames)

            if current_action in frame_indices and direction in frame_indices[current_action]:
                frames = frame_indices[current_action][direction]
                frame_index = frames[current_sprite % len(frames)]
                x, y = frame_index
                skin_spritesheet = SpriteSheet(selected_skin_tone)
                eye_spritesheet = SpriteSheet(selected_eye_color)
                player_sprite = skin_spritesheet.get_image(x, y, frame_width, frame_height)
                eye_sprite = eye_spritesheet.get_image(x, y, frame_width, frame_height)
                player_sprite.blit(eye_sprite, (0, 0))
                player_sprite = pygame.transform.scale(player_sprite, (18.75, 42.75))


        new_rect = pygame.Rect(new_x, new_y, player_tile.width, player_tile.height)

##### Comment out for Production
#        current_map.draw_grid()
#        for block_rect, _ in blocks:
#            pygame.draw.rect(screen, (255, 0, 0), block_rect)  # Draw no_passover blocks in red || DELETE color when it is time to begin creating actual tilesets
#        for block_rect, _ in pass_under_blocks:
#            pygame.draw.rect(screen, (0, 255, 0), block_rect)  # Draw passover blocks in green || DELETE color when it is time to begin creating actual tilesets
################################

        blocks[:], pass_under_blocks[:] = current_map.draw_map(screen)

        collision_check = any(check_collision(new_rect, block_rect, player_tile, tile, current_map, player1) for block_rect, tile in blocks)
        if game_area.contains(new_rect) and collision_check:
            player_tile.x = prev_x
            player_tile.y = prev_y

        screen.blit(player_sprite, (player_tile.x, player_tile.y))

        if ctrl_p_pressed:
            #print("CTRL + P has been pressed.")
            info_lines = [f"Name: {player1.name}", f"Health: {player1.current_health} / {player1.max_health}", f"Level: {player1.level}"]
            for i, line in enumerate(info_lines):
                info_surface = font.render(line, True, (255, 255, 255))
                screen.blit(info_surface, (screen_width - info_surface.get_width() - 50, screen_height - (len(info_lines) - i) * info_surface.get_height() - 50))

        if ctrl_i_pressed:
            #print("CTRL + I has been pressed.")
            header = ["Item Name", "QTY", "Item Description"]
            info_lines = [header]
            mouse_pos = pygame.mouse.get_pos()
            if player1.bag:
                for item in player1.bag:
                    item_name = item.name
                    item_qty = str(item.qty)
                    item_description = item.description
                    line = [item_name, item_qty, item_description]
                    info_lines.append(line)
            y_offset = 50
            for index, line in enumerate(info_lines):
                line_height = 0
                for i, text in enumerate(line):
                    text = str(text)
                    max_width = max_widths[i]
                    adjusted_font = adjust_font_size(text, max_width, 'Arial')
                    text_surface = adjusted_font.render(text, True, (255, 255, 255))
                    if i == 0:  # Left align
                        x_offset = 50
                    elif i == 1:  # Center align
                        x_offset = 50 + max_widths[0] + (max_widths[1] - text_surface.get_width()) // 2
                    elif i == 2:  # Left align
                        x_offset = 50 + max_widths[0] + max_widths[1]
                    screen.blit(text_surface, (x_offset, y_offset))
                    line_height = max(line_height, text_surface.get_height())
                if index > 0:
                    item_rects.append(pygame.Rect(50, y_offset, sum(max_widths), line_height))
                y_offset += line_height + 5
            for item_rect in item_rects:
                if item_rect.collidepoint(mouse_pos):
                    pygame.draw.rect(screen, (0, 255, 0), item_rect, 2)  # Draw a neon green border


        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_p and pygame.key.get_mods() & pygame.KMOD_CTRL:
                    ctrl_p_pressed = True
                elif event.key == pygame.K_i and pygame.key.get_mods() & pygame.KMOD_CTRL:
                    ctrl_i_pressed = not ctrl_i_pressed
            elif event.type == pygame.KEYUP:
                if event.key == pygame.K_p:
                    ctrl_p_pressed = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if event.button == 1:  # Left mouse button
                    global dragging, drag_offset_x, drag_offset_y
                    for i, item_rect in enumerate(item_rects):
                        if item_rect.collidepoint(event.pos):  # If mouse clicked on the item
                            pygame.draw.rect(screen, (0, 255, 0), item_rect, 2)  # Draw a neon green border
                            item = player1.bag[i]  # Get the corresponding item from the bag
                            print(f"Clicked item: {item.name}, is_consumable: {item.is_consumable}")
                            if item.is_consumable:
                                player1.use_item(item.name)
                                print(f"{item.name} has been consumed")
                            else:
                                print(f"{item.name} has been clicked")
                            break
                    if minimize_button.collidepoint(event.pos):
                        pygame.display.iconify()
                    elif close_button.collidepoint(event.pos):
                        pygame.quit()
                        sys.exit()
                    if title_bar_rect.collidepoint(event.pos):
                        dragging = True
                        rect = gw.getActiveWindow()
                        drag_offset_x = event.pos[0]
                        drag_offset_y = event.pos[1]
            elif event.type == pygame.MOUSEBUTTONUP:
                if event.button == 1:
                    dragging = False
            elif event.type == pygame.MOUSEMOTION:
                if dragging:
                    mouse_x, mouse_y = pygame.mouse.get_pos()
                    new_x = rect.left + (mouse_x - drag_offset_x)
                    new_y = rect.top + (mouse_y - drag_offset_y)
                    print(f"Moving window to: ({new_x}, {new_y})")
                    rect.moveTo(new_x, new_y)


        title_text_width, minimize_button, close_button, title_bar_height = draw_title_bar(screen)
        title_bar_rect = pygame.Rect(0, 0, screen_width, title_bar_height)

        draw_health_bar(screen, player1.current_health, player1.max_health, title_text_width)

        pygame.display.flip()
        pygame.time.Clock().tick(60)

main()
pygame.quit()